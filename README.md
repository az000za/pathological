# pathological
Go from State A to State B. And possibly maintain desired state.

a) Examples of StateA to StateB. Same Type to Type  <br>
a.1) Path needed to go from Position A to Position B.  <br>
a.2) Path needed to go from Graph A to Graph B <br>
a.3) Path needed to go from Stats A to Stats B <br>
a.4) Path needed to go from Number A to Number B. <br>
a.5) Path needed to go from String A to String B. <br>
a.6) Path needed to go from Character A to Character B.  <br>
a.7) Path needed to go from LocationA to LocationB. <br>
a.8) Path needed to go from LanguageA to LanguageB. <br>
a.8) Path needed to go from MetricsA to MetricsB. <br>
a.9) Path needed to go from FormUnFilled to FormFilledOut  <br>

Q: What does Pathological mean to Me? <br>
A: It means to go from point A to point B on the map. <br>
Q: What do you mean by point A to point B? <br>
A: To change the status from stateA to stateB. <br>
A: View example A for clarity. <br>
Q: What do you mean by map? <br>
A: Forget about patterns. Patterns are identified over time. <br>
A: Maps are where the data is held. <br>
A: Regardless of all the "different" maps out there. <br>
A: there is only one universal map. <br>
A: Pathological will be able to traverse any map. <br>
A: establishing pathways. <br>

Q: So your traversing a map? How do you keep track of all the steps instead of truncating? <br>
Q: How will you make it so the algorithm can traverse with missing information? <br>
A: I will be able to traverse a map by inferring the rules from the column and other columns. <br>


# Code Outline

class Pathological {

    nodes = {};
    
    paths = [
      trail[]
    ]
    constructor(){
        
    }
    findPath(fromStateA, toStateB, foundConstraints, avoidState){
    
    }
    connectPath(linkNodeA, toNodeB){
      
    }
    hopPaths(){
      
    }
    traverser(){
      
    }
}

class Node {

}

class Link {
  // the connection between at least to nodes.
}

class Path {

}

class Trail {

}
