# pathological
Go from State A to State B. And possibly maintain desired state.

a) Examples of StateA to StateB. Same Type to Type
a.1) Path needed to go from Position A to Position B. 
a.2) Path needed to go from Graph A to Graph B
a.3) Path needed to go from Stats A to Stats B
a.4) Path needed to go from Number A to Number B.
a.5) Path needed to go from String A to String B.
a.6) Path needed to go from Character A to Character B.
a.7) Path needed to go from LocationA to LocationB.
a.8) Path needed to go from LanguageA to LanguageB.
a.8) Path needed to go from MetricsA to MetricsB.
a.9) Path needed to go from FormUnFilled to FormFilledOut

Q: What does Pathological mean to Me? <br>
A: It means to go from point A to point B on the map. <br>
Q: What do you mean by point A to point B? <br>
A: To change the status from stateA to stateB. <br>
A: View example A for clarity. <br>
Q: What do you mean by map? <br>
A: Forget about patterns. Patterns are identified over time. <br>
A: Maps are where the data is held. <br>
A: Regardless of all the "different" maps out there. <br>
A: there is only one universal map. <br>
A: Pathological will be able to traverse any map. <br>
A: establishing pathways. <br>

Q: So your traversing a map? How do you keep track of all the steps instead of truncating? <br>
Q: How will you make it so the algorithm can traverse with missing information? <br>
A: I will be able to traverse a map by inferring the rules from the column and other columns. <br>


# Code Outline

class Pathological {

    nodes = {};
    
    paths = [
      trail[]
    ]
    constructor(){
        
    }
    findPath(fromStateA, toStateB, foundConstraints, avoidState){
    
    }
    connectPath(linkNodeA, toNodeB){
      
    }
    hopPaths(){
      
    }
    traverser(){
      
    }
}

class Node {

}

class Link {
  // the connection between at least to nodes.
}

class Path {

}

class Trail {

}
